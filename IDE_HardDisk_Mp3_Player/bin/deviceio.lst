C51 COMPILER V9.52.0.0   DEVICEIO                                                          03/27/2018 22:42:44 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE DEVICEIO
OBJECT MODULE PLACED IN .\bin\deviceio.obj
COMPILER INVOKED BY: C:\Keil_c51\C51\BIN\C51.EXE znFAT\deviceio.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\bin\deviceio.l
                    -st) TABS(2) OBJECT(.\bin\deviceio.obj)

line level    source

   1          #include "mytype.h"
   2          #include "config.h"
   3          #include "deviceio.h"
   4          
   5          //#include "sd.h" //´æ´¢Éè±¸Çı¶¯Í·ÎÄ¼ş
   6          //#include "ch375.h" //´æ´¢Éè±¸Çı¶¯Í·ÎÄ¼ş
   7          #include "ATAPI6.h"  //Ó²ÅÌÇı¶¯Í·ÎÄ¼ş
   8          
   9          struct znFAT_IO_Ctl ioctl; //ÓÃÓÚÉÈÇø¶ÁĞ´µÄIO¿ØÖÆ£¬¾¡Á¿¼õÉÙÎïÀíÉÈÇø²Ù×÷£¬Ìá¸ßĞ§ÂÊ
  10          extern UINT8 Dev_No; //Éè±¸ºÅ
  11          extern UINT8 *znFAT_Buffer;
  12          
  13          /*******************************************************************
  14           ¹¦ÄÜ£º´æ´¢Éè±¸³õÊ¼»¯
  15           ĞÎ²Î£ºÎŞĞÎ²Î
  16           ·µ»Ø£º´æ´¢Éè±¸³õÊ¼»¯´íÎóĞÅÏ¢
  17           Ïê½â£ºznFATÖ§³Ö¶àÉè±¸£¬¼´Í¬Ê±¹Ò½Ó¶àÖÖ´æ´¢Éè±¸£¬ËùÓĞ´æ´¢Éè±¸µÄ³õÊ¼
  18                 »¯¾ùÔÚÕâÀïÍê³É¡£·µ»ØÖµµÄÄ³Ò»Î»Îª1£¬ÔòËµÃ÷ÏàÓ¦µÄ´æ´¢Éè±¸³õÊ¼
  19                 »¯Ê§°Ü¡£ÀıÈç£ºÉè±¸0Ê§°Ü£¬¶øÆäËüÉè±¸¾ù³É¹¦£¬Ôò·µ»ØÖµÎª0X01¡¢
  20                 Éè±¸1ÓëÉè±¸2Ê§°Ü£¬¶øÆäËüÉè±¸³É¹¦£¬Ôò·µ»ØÖµÎª0X06¡£ÎªÁËÊ¹·µ»Ø
  21                 ÖµÈçÊµµÄ·´Ó³ÏàÓ¦Éè±¸µÄ³õÊ¼»¯×´Ì¬£¬Çë×¢Òâ´æ´¢Éè±¸³õÊ¼»¯º¯Êı
  22                 µ÷ÓÃµÄË³Ğò¡£
  23          *******************************************************************/
  24          
  25          UINT8 znFAT_Device_Init(void) 
  26          {
  27   1       UINT8 res=0,err=0;
  28   1      
  29   1       ioctl.just_dev=0;
  30   1       ioctl.just_sec=0;
  31   1      
  32   1       //ÒÔÏÂÎª¸÷´æ´¢Éè±¸µÄ³õÊ¼»¯º¯Êıµ÷ÓÃ£¬ÇëÑØÏ®ÒÔÏÂ¸ñÊ½
  33   1      
  34   1      // res=SdCard_Init(); 
  35   1      //  res=CH375_InitDisk(); //±ØĞëÈ·±£´æ´¢Éè±¸Çı¶¯³ÌĞòÊÇÍêÃÀ¿ÉÓÃµÄ£¬·ñÔò³öÏÖÎÊÌâ¿É²»ÊÇÎÄ¼şÏµÍ³²ãµÄÔ­Òò¡£
  36   1        res=HDD_Init();   //´æ´¢Éè±¸³õÊ¼»¯º¯ÊıºÍznFAT¹Ò½Ó µÚÒ»Ïî£¬Ò»¹²6Ïî¡£
  37   1       if(res) err|=0X01;
  38   1      
  39   1       //res=Device1_Init();
  40   1       //if(res) err|=0X02;
  41   1      
  42   1       return err; //·µ»Ø´íÎóÂë£¬Èç¹ûÄ³Ò»Éè±¸³õÊ¼»¯Ê§°Ü£¬ÔòerrÏàÓ¦Î»Îª1
  43   1      }
  44          
  45          /*****************************************************************************
  46           ¹¦ÄÜ£ºznFATµÄ´æ´¢Éè±¸ÎïÀíÉÈÇø¶ÁÈ¡Çı¶¯½Ó¿Ú
  47           ĞÎ²Î£ºaddr:ÎïÀíÉÈÇøµØÖ· buffer:Êı¾İ»º³åÇøÖ¸Õë
  48           ·µ»Ø£º0
  49           Ïê½â£º¸÷´æ´¢Éè±¸µÄÎïÀíÉÈÇø¶ÁÈ¡Çı¶¯º¯Êı·Åµ½caseµÄ¸÷¸ö·ÖÖ§ÖĞ£¬·ÖÖ§ĞòºÅ¾ÍÊÇ´ËÉè
  50                 ±¸µÄÉè±¸ºÅ¡£ 
  51          *****************************************************************************/
  52          UINT8 znFAT_Device_Read_Sector(UINT32 addr,UINT8 *buffer)
  53          {
  54   1       if(buffer==znFAT_Buffer) //Èç¹ûÊÇÕë¶ÔznFATÄÚ²¿»º³åÇøµÄ²Ù×÷
C51 COMPILER V9.52.0.0   DEVICEIO                                                          03/27/2018 22:42:44 PAGE 2   

  55   1       {                        
  56   2        if(ioctl.just_dev==Dev_No  //Èç¹ûÏÖÔÚÒª¶ÁÈ¡µÄÉÈÇøÓëÄÚ²¿»º³åËù¶ÔÓ¦µÄÉÈÇø£¨¼´×î½üÒ»´Î²Ù×÷µÄÉÈÇø£©ÊÇÍ¬Ò»ÉÈÇ
             -ø
  57   2           && (ioctl.just_sec==addr && 0!=ioctl.just_sec)) //Ôò²»ÔÙ½øĞĞ¶ÁÈ¡£¬Ö±½Ó·µ»Ø
  58   2        {                                           
  59   3         return 0;      
  60   3        }
  61   2        else //·ñÔò£¬¾Í½«×î½üÒ»´Î²Ù×÷µÄÉÈÇø±ê¼ÇÎªµ±Ç°ÉÈÇø
  62   2        {
  63   3         ioctl.just_dev=Dev_No; 
  64   3         ioctl.just_sec=addr; 
  65   3        }
  66   2       }
  67   1      
  68   1       switch(Dev_No) //ÓĞ¶àÉÙ¸ö´æ´¢Éè±¸£¬¾ÍÓĞ¶àÉÙ¸öcase·ÖÖ§
  69   1       {
  70   2        case 0:
  71   2                 while(ReadSector(addr,buffer));  //¶ÁÈ¡Ò»¸öÉÈÇøº¯ÊıºÍznFAT¹Ò½Ó µÚ¶şÏî£¬Ò»¹²6Ïî¡£
  72   2              //   while(CH375_Read_Sector(addr,buffer));
  73   2               break;             //±ØĞëÈ·±£´æ´¢Éè±¸Çı¶¯³ÌĞòÊÇÍêÃÀ¿ÉÓÃµÄ£¬·ñÔò³öÏÖÎÊÌâ¿É²»ÊÇÎÄ¼şÏµÍ³²ãµÄÔ­Òò¡£
  74   2        //case 1:
  75   2      //       while(SD2_Read_Sector(addr,buffer));
  76   2      //       break;
  77   2        //case...
  78   2        
  79   2       }
  80   1      
  81   1       return 0;
  82   1      }
  83          
  84          /*****************************************************************************
  85           ¹¦ÄÜ£ºznFATµÄ´æ´¢Éè±¸ÎïÀíÉÈÇøĞ´ÈëÇı¶¯½Ó¿Ú
  86           ĞÎ²Î£ºaddr:ÎïÀíÉÈÇøµØÖ· buffer:Êı¾İ»º³åÇøÖ¸Õë
  87           ·µ»Ø£º0
  88           Ïê½â£º¸÷´æ´¢Éè±¸µÄÎïÀíÉÈÇøĞ´ÈëÇı¶¯º¯Êı·Åµ½caseµÄ¸÷¸ö·ÖÖ§ÖĞ£¬·ÖÖ§ĞòºÅ¾ÍÊÇ´ËÉè
  89                 ±¸µÄÉè±¸ºÅ¡£ 
  90          *****************************************************************************/
  91          UINT8 znFAT_Device_Write_Sector(UINT32 addr,UINT8 *buffer) 
  92          {
  93   1       if(buffer==znFAT_Buffer) //Èç¹ûÊı¾İ»º³åÇøÊÇÄÚ²¿»º³å
  94   1       {
  95   2        ioctl.just_dev=Dev_No; //¸üĞÂÎªµ±Ç°Éè±¸ºÅ
  96   2        ioctl.just_sec=addr; //¸üĞÂÎªµ±Ç°²Ù×÷µÄÉÈÇøµØÖ· 
  97   2       }
  98   1      
  99   1       switch(Dev_No)
 100   1       {
 101   2        case 0:
 102   2                   while(WriteSector(addr,buffer)); //Ğ´Ò»¸öÉÈÇøº¯ÊıºÍznFAT¹Ò½Ó µÚÈıÏî£¬Ò»¹²6Ïî¡£
 103   2              //  while(CH375_Write_Sector(addr,buffer));   //´æ´¢Éè±¸ºÍznFAT¹Ò½Ó£¬¾ÍÊÇÕâÃ´¼òµ¥£¡
 104   2               break;       //±ØĞëÈ·±£´æ´¢Éè±¸Çı¶¯³ÌĞòÊÇÍêÃÀ¿ÉÓÃµÄ£¬·ñÔò³öÏÖÎÊÌâ¿É²»ÊÇÎÄ¼şÏµÍ³²ãµÄÔ­Òò¡£
 105   2        //case 1:
 106   2      //       while(SD2_Write_Sector(addr,buffer));
 107   2      //       break;
 108   2        //case...
 109   2        
 110   2       } 
 111   1      
 112   1       return 0;
 113   1      }
 114          
 115          /***********************************************************************************
C51 COMPILER V9.52.0.0   DEVICEIO                                                          03/27/2018 22:42:44 PAGE 3   

 116           ¹¦ÄÜ£ºznFATµÄ´æ´¢Éè±¸ÎïÀíÉÈÇøÁ¬Ğø¶ÁÈ¡Çı¶¯½Ó¿Ú
 117           ĞÎ²Î£ºnsec:Òª¶ÁÈ¡µÄÉÈÇøÊı addr:Á¬ĞøÉÈÇø¶ÁÈ¡Ê±µÄ¿ªÊ¼ÉÈÇøµØÖ· buffer:Êı¾İ»º³åÇøÖ¸Õë
 118           ·µ»Ø£º0
 119           Ïê½â£º´Ëº¯Êı½Ó¿ÚÔÚznFATÖĞÓÃÓÚÍê³ÉÈô¸É¸öÁ¬ĞøÉÈÇøµÄÒ»´ÎĞÔ¶ÁÈ¡¡£´Ëº¯Êı½Ó¿ÚµÄÊµÏÖÓĞÁ½ÖÖ
 120                 Ä£Ê½ 1¡¢µ¥ÉÈÇø¶ÁÈ¡Çı¶¯+Ñ­»· 2¡¢´æ´¢Éè±¸Ó²¼şÉÏµÄÁ¬ĞøÉÈÇø¶ÁÈ¡ Ê¹ÓÃ2±È1µÄĞ§ÂÊÒª
 121                 µÃ¶à£¬ÔÚ¸ßËÙÇÒÊı¾İÁ¿±È½Ï´óµÄÓ¦ÓÃ³¡ºÏ£¬½¨ÒéÊ¹ÓÃÕßÌá¹©Ó²¼ş¼¶µÄÁ¬ĞøÉÈÇø¶ÁÈ¡º¯Êı
 122          ***********************************************************************************/
 123          UINT8 znFAT_Device_Read_nSector(UINT32 nsec,UINT32 addr,UINT8 *buffer)
 124          {
 125   1       UINT32 i=0;
 126   1      
 127   1       if(0==nsec) return 0;
 128   1      
 129   1       #ifndef USE_MULTISEC_R //´Ëºê¾ö¶¨ÊÇ·ñÊ¹ÓÃÓ²¼ş¼¶Á¬ĞøÉÈÇø¶ÁÈ¡Çı¶¯
 130   1      
 131   1        switch(Dev_No)
 132   1        {
 133   2         case 0:
 134   2                for(i=0;i<nsec;i++) //Èç¹û²»Ê¹ÓÃÓ²¼ş¼¶Á¬ĞøÉÈÇø¶ÁÈ¡£¬ÔòÊ¹ÓÃµ¥ÉÈÇø¶ÁÈ¡+Ñ­»·µÄ·½Ê½
 135   2                { 
 136   3             while(ReadSector(addr+i,buffer));    //¶Án¸öÉÈÇøº¯ÊıºÍznFAT¹Ò½Ó µÚ4Ïî£¬Ò»¹²6Ïî¡£
 137   3                // while(SD1_Read_Sector(addr+i,buffer));
 138   3                 buffer+=512;
 139   3                }
 140   2                break;
 141   2        // case 1:
 142   2         //       for(i=0;i<nsec;i++) //Èç¹û²»Ê¹ÓÃÓ²¼ş¼¶µÄÁ¬ĞøÉÈÇø¶ÁÈ¡£¬ÔòÊ¹ÓÃµ¥ÉÈÇø¶ÁÈ¡+Ñ­»·µÄ·½Ê½
 143   2        //        {
 144   2         //        while(SD2_Read_Sector(addr+i,buffer));
 145   2         //        buffer+=512;
 146   2         //       }
 147   2        //        break;
 148   2        }
 149   1      
 150   1       #else
              
                switch(Dev_No)
                {
                 case 0:
                  while(  ReadnSector(addr,buffer, nsec ));//¶Án¸öÉÈÇøº¯ÊıºÍznFAT¹Ò½Ó µÚ4Ïî£¬Ò»¹²6Ïî¡£  
                      //  while(Device0_Read_nSector(nsec,addr,buffer));
                 //case 1:
                        //while(Device1_Read_nSector(nsec,addr,buffer));
                }
               #endif
 161   1      
 162   1       return 0;
 163   1      }
 164          
 165          /***********************************************************************************
 166           ¹¦ÄÜ£ºznFATµÄ´æ´¢Éè±¸ÎïÀíÉÈÇøÁ¬ĞøĞ´ÈëÇı¶¯½Ó¿Ú
 167           ĞÎ²Î£ºnsec:ÒªĞ´ÈëµÄÉÈÇøÊı addr:Á¬ĞøÉÈÇøĞ´ÈëÊ±µÄ¿ªÊ¼ÉÈÇøµØÖ· buffer:Êı¾İ»º³åÇøÖ¸Õë
 168           ·µ»Ø£º0
 169           Ïê½â£º´Ëº¯Êı½Ó¿ÚÓëÉÏÃæµÄÁ¬Ğø¶ÁÈ¡Çı¶¯½Ó¿ÚÍ¬Àí¡£
 170          ***********************************************************************************/
 171          UINT8 znFAT_Device_Write_nSector(UINT32 nsec,UINT32 addr,UINT8 *buffer)
 172          {
 173   1       UINT32 i=0;
 174   1       
 175   1       if(0==nsec) return 0;
 176   1      
 177   1       #ifndef USE_MULTISEC_W //´Ëºê¾ö¶¨ÊÇ·ñÊ¹ÓÃÓ²¼şµÄÁ¬ĞøÉÈÇøĞ´Èëº¯Êı
C51 COMPILER V9.52.0.0   DEVICEIO                                                          03/27/2018 22:42:44 PAGE 4   

 178   1      
 179   1        switch(Dev_No)
 180   1        {
 181   2         case 0:
 182   2                for(i=0;i<nsec;i++)
 183   2                {
 184   3            while(WriteSector(addr+i,buffer));    //Ğ´n¸öÉÈÇøº¯ÊıºÍznFAT¹Ò½Ó µÚ5Ïî£¬Ò»¹²6Ïî¡£
 185   3                // while(SD1_Write_Sector(addr+i,buffer));
 186   3                 buffer+=512;
 187   3                }
 188   2            break;
 189   2         //case 1:
 190   2         //       for(i=0;i<nsec;i++)
 191   2         //       {
 192   2         //        while(SD2_Write_Sector(addr+i,buffer));
 193   2         //        buffer+=512;
 194   2          //      }
 195   2      //      break;
 196   2        }
 197   1        
 198   1       #else
              
                switch(Dev_No)
                {
                 case 0:
                    while(  WritenSector( addr, buffer, nsec));   //Ğ´n¸öÉÈÇøº¯ÊıºÍznFAT¹Ò½Ó µÚ5Ïî£¬Ò»¹²6Ïî¡£
                      //  while(SD_Write_nSector(nsec,addr,buffer));
                    break;
                 //case 1:
                        //while(Device1_Write_nSector(nsec,addr,buffer));
                }
              
               #endif
 211   1      
 212   1       return 0; 
 213   1      }
 214          
 215          /***********************************************************************************
 216           ¹¦ÄÜ£ºznFATµÄ´æ´¢Éè±¸ÎïÀíÉÈÇøÁ¬ĞøÇå0Çı¶¯½Ó¿Ú
 217           ĞÎ²Î£ºnsec:ÒªÇå0µÄÉÈÇøÊı addr:Á¬ĞøÉÈÇøÇå0µÄ¿ªÊ¼ÉÈÇøµØÖ·
 218           ·µ»Ø£º0
 219           Ïê½â£ºÔÚ¸ñÊ½»¯¹¦ÄÜÖĞ£¬×îºÄÊ±µÄ¾ÍÊÇ¶ÔFAT±íÉÈÇøÉÈÇøµÄÖğ¸öÇå0£¬Ê¹ÓÃÓ²¼ş¼¶µÄÁ¬ĞøÉÈÇøÇå0
 220                 Çı¶¯º¯Êı½«¿ÉÒÔºÜ´ó³Ì¶ÈÉÏ¼ÓËÙÕâÒ»¹ı³Ì¡£
 221          ***********************************************************************************/
 222          UINT8 znFAT_Device_Clear_nSector(UINT32 nsec,UINT32 addr)
 223          {
 224   1       #ifndef USE_MULTISEC_CLEAR  //´Ëºê¾ö¶¨ÊÇ·ñÊ¹ÓÃÓ²¼ş¼¶Á¬ĞøÉÈÇøÇå0º¯Êı£¬ÆäÖ÷ÒªÓÃÓÚ¸ñÊ½»¯¹ı³ÌÖĞFAT±íµÄÇå0
 225   1        UINT32 i=0;
 226   1      
 227   1        for(i=0;i<512;i++) //Çå¿ÕÄÚ²¿»º³åÇø£¬ÓÃÓÚÁ¬ĞøÉÈÇøÇå0
 228   1        {
 229   2         znFAT_Buffer[i]=0;
 230   2        }
 231   1      
 232   1        switch(Dev_No)
 233   1        {
 234   2         case 0:
 235   2                for(i=0;i<nsec;i++)
 236   2                {
 237   3             while(WriteSector(addr+i,znFAT_Buffer));  //Ğ´1¸öÉÈÇøº¯ÊıºÍznFAT¹Ò½Ó µÚ5Ïî£¬Ò»¹²6Ïî¡£
 238   3                                //×¢ÒâÕâÀïµÄµÚ¶ş¸ö²ÎÊıÊÇznFATµÄÄÚ²¿»º³åÇø znFAT_Buffer
 239   3               //  while(SD1_Write_Sector(addr+i,znFAT_Buffer));
C51 COMPILER V9.52.0.0   DEVICEIO                                                          03/27/2018 22:42:44 PAGE 5   

 240   3                }
 241   2                break;
 242   2         //case 1:
 243   2         //       for(i=0;i<nsec;i++)
 244   2         //       {
 245   2          //       while(SD2_Write_Sector(addr+i,znFAT_Buffer));
 246   2         //       }
 247   2         //       break;
 248   2        }
 249   1      
 250   1       #else
              
                switch(Dev_No)
                {
                 case 0:
                        return Device0_Clear_nSector(nsec,addr); //ÔÚÊ¹ÓÃÓ²¼ş¼¶µÄÁ¬ĞøÉÈÇøÇå0µÄÊ±ºò£¬Çë½«Á¬ĞøÉÈÇøÇå0º¯ÊıĞ
             -´ÔÚÕâÀï
                 //case 1:
                        //return Device1_Clear_nSector(nsec,addr);
                }
              
               #endif
 261   1      
 262   1       ioctl.just_dev=Dev_No; //¸üĞÂÎªµ±Ç°Éè±¸ºÅ
 263   1       ioctl.just_sec=(addr+nsec-1); //¸üĞÂÎªµ±Ç°²Ù×÷µÄÉÈÇøµØÖ·  
 264   1      
 265   1       return 0;  
 266   1      }
 267          
 268          //==============================¡¾ÒÔÉÏÊÇÉè±¸Çı¶¯²ã¡¿======================================================
             -==================
 269          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1085    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      5      57
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
